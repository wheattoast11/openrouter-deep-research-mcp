# v2.0 Architecture: Agentic Intelligence Platform

## Overview

Version 2.0 transforms the OpenRouter Agents server from a powerful research tool into a **proactive, bidirectional agentic platform** that represents a true step-change in human-agent collaboration.

## Core Architectural Principles

### 1. Intelligence as a Two-Way Street

**Traditional AI**: Passive, request-response
```
Human → Request → AI → Response → (End)
```

**v2.0 Agentic**: Continuous, bidirectional partnership
```
Human ⇄ Continuous Session ⇄ Agent
  ↓         ↓         ↓
Steer    Context   Proactive
         Provide   Suggestions
```

The agent can:
- Receive steering commands mid-task
- Accept new context at any time
- Proactively notify of new insights
- Schedule its own future actions

### 2. Persistent, Evolving Memory

Every research session enriches a **Universal Knowledge Graph**:

```
Research "PGlite" → Extract Entities → Build Graph
  ↓
Entities: [PGlite, PostgreSQL, SQLite, WASM, serverless]
  ↓
Relationships: [
  PGlite --is_a--> PostgreSQL
  PGlite --uses--> WASM
  PGlite --related_to--> serverless
]
  ↓
Future queries benefit from accumulated knowledge
```

### 3. Temporal Awareness

The agent operates in **continuous time**, not just in response to requests:

- Schedule daily briefings
- Monitor topics hourly/daily/weekly
- Proactively alert on new information
- Execute research on a timeline

### 4. Multi-Modal, Multi-Source Retrieval

Unified retrieval across:
1. **Knowledge Graph**: Entity-relationship queries
2. **Vector Store**: Semantic similarity (768D embeddings)
3. **BM25 Index**: Keyword/phrase matching
4. **Past Reports**: Historical research context

## Component Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         Transport Layer                         │
│  ┌──────────────┐  ┌───────────────┐  ┌──────────────────────┐ │
│  │    STDIO     │  │ Streamable    │  │     WebSocket        │ │
│  │  (IDE/CLI)   │  │  HTTP (/mcp)  │  │   (/mcp/ws) ★NEW★    │ │
│  └──────────────┘  └───────────────┘  └──────────────────────┘ │
│         ↓                  ↓                      ↓              │
└─────────┼──────────────────┼──────────────────────┼─────────────┘
          │                  │                      │
          └──────────────────┴──────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                        MCP Server Core                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │             Tool Registry & Routing                      │  │
│  │  • Agent (unified entry point)                           │  │
│  │  • Research (sync/async)                                 │  │
│  │  • Retrieve (graph + vector + BM25)  ★ENHANCED★        │  │
│  │  • Schedule Actions  ★NEW★                              │  │
│  │  • Query Graph  ★NEW★                                   │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │          MCP Protocol Handlers                           │  │
│  │  • Tools (list, call)                                    │  │
│  │  • Prompts (list, get) + Magic Workflows  ★ENHANCED★   │  │
│  │  • Resources (list, read, subscribe)  ★ENHANCED★       │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Agent Orchestration                        │
│                                                                 │
│  ┌──────────────┐      ┌────────────────┐      ┌────────────┐ │
│  │   Planning   │─────→│    Research    │─────→│  Context   │ │
│  │   Agent      │      │    Agent       │      │  Agent     │ │
│  │              │      │  (Ensemble)    │      │ (Synthesis)│ │
│  │ • Decompose  │      │  • Parallel    │      │ • Cite     │ │
│  │ • Classify   │      │  • Vision      │      │ • Fuse     │ │
│  │ • Refine     │      │  • Domain      │      │ • Stream   │ │
│  └──────────────┘      └────────────────┘      └─────┬──────┘ │
│                                                       │        │
│                              Auto-Extract ────────────┘        │
│                                    ↓                           │
│  ┌──────────────┐      ┌────────────────┐                     │
│  │  Temporal    │      │   Knowledge    │                     │
│  │  Agent       │      │   Graph Mgr    │  ★NEW★             │
│  │              │      │                │                     │
│  │ • Schedule   │      │ • Extract      │                     │
│  │ • Monitor    │      │ • Relate       │                     │
│  │ • Brief      │      │ • Query        │                     │
│  └──────────────┘      └────────────────┘                     │
└─────────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Data & State Layer                           │
│                                                                 │
│  ┌────────────────────────────────────────────────────────┐   │
│  │              PGlite Database (File/Memory)             │   │
│  │                                                         │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐│   │
│  │  │ Reports  │  │  Jobs    │  │  Nodes   │  │ Edges  ││   │
│  │  │ + Vector │  │ + Events │  │ + Vector │  │ + Meta ││   │
│  │  └──────────┘  └──────────┘  └──────────┘  └────────┘│   │
│  │                                                         │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐             │   │
│  │  │  Index   │  │  Index   │  │ Idempo-  │             │   │
│  │  │   Docs   │  │ Postings │  │  tency   │             │   │
│  │  └──────────┘  └──────────┘  └──────────┘             │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌────────────────────────────────────────────────────────┐   │
│  │           Multi-Tier Caching                           │   │
│  │  • Semantic Cache (vector similarity)                  │   │
│  │  • Exact Match Cache (hash-based)                      │   │
│  │  • Model Response Cache (per-model)                    │   │
│  └────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## New Communication Patterns

### 1. WebSocket Bidirectional Flow

```
Client                          Server
  │                               │
  ├──── WS Connect ──────────────→│
  │←──── session.started ─────────┤
  │                               │
  ├──── JSON-RPC: tools/call ────→│
  │                               ├─ [Processing...]
  │←──── agent.thinking ──────────┤
  │←──── agent.status_update ─────┤
  │                               │
  ├──── agent.steer ─────────────→│  (Mid-task steering)
  │←──── agent.steered ───────────┤
  │                               │
  │←──── Result ──────────────────┤
  │                               │
  │      [Later, proactively]     │
  │←──── temporal.monitor_update ─┤
  │←──── agent.proactive_suggestion┤
```

### 2. Resource Subscription Pattern

```
Client subscribes to: mcp://knowledge_base/updates
  ↓
Server tracks subscription
  ↓
New report added to DB
  ↓
GraphManager extracts entities
  ↓
Server sends update to ALL subscribers:
  {
    type: 'resource.updated',
    uri: 'mcp://knowledge_base/updates',
    data: { newEntities: 3, newRelationships: 5 }
  }
```

### 3. Temporal Execution Pattern

```
User: schedule_action { cron: "0 9 * * *", action: { type: "briefing" } }
  ↓
TemporalAgent creates cron task
  ↓
Every day at 9 AM:
  ├─ Execute action (briefing)
  ├─ Generate summary
  └─ Broadcast via WebSocket: temporal.briefing_generated
```

## Knowledge Graph Schema

### Nodes
```sql
graph_nodes (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE,           -- Entity name (e.g., "PGlite")
  type TEXT,                  -- person | organization | concept | technology | location
  metadata JSONB,             -- { description, sourceReportId, confidence, ... }
  embedding VECTOR(768),      -- Semantic embedding
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)
```

### Edges
```sql
graph_edges (
  id SERIAL PRIMARY KEY,
  source_node_id INT,
  target_node_id INT,
  relation_type TEXT,         -- is_a | part_of | related_to | uses | implements
  metadata JSONB,             -- { description, sourceReportId, confidence, ... }
  created_at TIMESTAMPTZ,
  UNIQUE (source_node_id, target_node_id, relation_type)
)
```

### Extraction Flow

```
Report Text → LLM (Entity Extraction) → Entities []
  ↓
Entities [] → LLM (Relationship Extraction) → Relationships []
  ↓
Entities → graph_nodes (with embeddings)
  ↓
Relationships → graph_edges
```

## Retrieval Strategy Evolution

### v1.x: Vector + BM25 Hybrid

```
Query → [BM25 (70%) + Vector (30%)] → Ranked Results
```

### v2.0: Graph + Vector + BM25 Unified

```
Query
  ├─→ Knowledge Graph (entity exact match)
  ├─→ Vector Similarity (semantic)
  └─→ BM25 (keyword)
       ↓
  Synthesize all sources → Unified Response
  {
    knowledge_graph: { entity, relationships },
    search_results: [...]
  }
```

## Magic Workflow Prompts (Implementation)

### `summarize_and_learn`
```
1. If URL: fetch_url → Extract text
2. conduct_research with fetched content
3. GraphManager.extractEntities
4. GraphManager.extractRelationships
5. Add all to graph_nodes and graph_edges
6. Return: Research summary + Graph stats
```

### `daily_briefing`
```
1. dbClient.listRecentReports(limit)
2. temporalAgent.getAllSchedules()
3. Format as markdown briefing
4. Return structured summary
```

### `continuous_query`
```
1. temporalAgent.schedule(cron, { type: 'monitor', query })
2. Enable schedule
3. Every cron trigger:
   a. searchHybrid(query)
   b. If new results: broadcast via WebSocket
4. Return: scheduleId for management
```

## Environment Variables (v2.0)

### New in v2.0

```bash
# WebSocket configuration
WS_HEARTBEAT_INTERVAL=30000      # Ping interval (ms)
WS_MAX_CONNECTIONS=100           # Max concurrent sessions
ALLOW_WS_NO_AUTH=false           # Require token for WS

# Temporal agent
TEMPORAL_ENABLED=true            # Enable scheduling
TEMPORAL_MAX_SCHEDULES=50        # Max concurrent schedules
TEMPORAL_DEFAULT_TZ=UTC          # Default timezone

# Knowledge graph
GRAPH_AUTO_EXTRACT=true          # Auto-extract from reports
GRAPH_EXTRACTION_MODEL=openai/gpt-5-mini
GRAPH_MIN_CONFIDENCE=0.7         # Entity extraction threshold
```

### Updated Defaults (v2.0)

```bash
MODE=AGENT                       # Changed from ALL to AGENT
MCP_STREAMABLE_HTTP_ENABLED=true # Streamable HTTP is default
MCP_SSE_ENABLED=false            # SSE deprecated in favor of WebSocket
```

## Client Integration Patterns

### Pattern 1: HTTP Only (Backward Compatible)
```javascript
const client = new Client(...)
await client.connect(httpTransport)
await client.callTool({ name: 'agent', arguments: {...} })
```

### Pattern 2: WebSocket Only (New Features)
```javascript
const ws = new WebSocket('ws://localhost:3008/mcp/ws?token=TOKEN')
ws.on('message', handleAgentEvent)
ws.send({ type: 'agent.steer', payload: {...} })
```

### Pattern 3: Hybrid (Recommended)
```javascript
// HTTP for tool calls
const httpClient = new Client(...)

// WebSocket for bidirectional features
const ws = new WebSocket(...)
ws.on('message', (data) => {
  const msg = JSON.parse(data)
  if (msg.type === 'temporal.action_triggered') {
    // Proactive notification received
  }
})
```

## Security Considerations

### WebSocket Authentication

- Token-based auth via query param: `?token=YOUR_TOKEN`
- Same validation as HTTP (SERVER_API_KEY or JWT)
- `ALLOW_WS_NO_AUTH` for development only

### Knowledge Graph Privacy

- Entities extracted are stored server-side
- Set `GRAPH_AUTO_EXTRACT=false` to disable automatic extraction
- Use `/query_graph` with caution for sensitive topics

### Temporal Actions

- Scheduled actions run in server context
- Ensure SERVER_API_KEY is strong and rotated
- Limit `TEMPORAL_MAX_SCHEDULES` to prevent abuse

## Performance Characteristics

### WebSocket Overhead

- ~2KB per session (memory)
- <1ms message latency (local)
- Heartbeat every 30s (configurable)

### Knowledge Graph Extraction

- ~1-2 LLM calls per report (entity + relationship extraction)
- ~500-1000 tokens per extraction
- Amortized over report value

### Temporal Scheduling

- Negligible CPU when idle
- Cron evaluation: ~1ms per check
- Scales to 100+ concurrent schedules

## Migration Path

1. **Phase 1**: Deploy v2.0, continue using HTTP (zero changes)
2. **Phase 2**: Add WebSocket client for proactive notifications
3. **Phase 3**: Use magic prompts for common workflows
4. **Phase 4**: Leverage knowledge graph for improved retrieval

All phases are **optional and incremental**.

## Testing v2.0 Features

```bash
# Test WebSocket transport
npm run test:ws

# Test temporal scheduling
npm run test:temporal

# Test knowledge graph
npm run test:graph

# Full v2.0 suite
npm run test:v2
```

## Future Roadmap (v2.x)

- **v2.1**: Multi-tenant sessions with isolated knowledge graphs
- **v2.2**: Voice interface via Gemini 2.5 Live integration
- **v2.3**: Multi-agent swarms with emergent behavior
- **v2.4**: Federated knowledge graphs across server instances

---

**This is a new paradigm. Intelligence is no longer a service you call—it's a partner that collaborates with you continuously.**

